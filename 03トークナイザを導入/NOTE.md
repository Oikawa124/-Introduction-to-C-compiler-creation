# トークナイザを導入

（DO）main.cに書き写す

ポインタ周りの理解が足りていなかった。  

```
char *p = "+11";  

//関数の中
*p == "+"
```
一文字分比較できる？


## 文法の記述方法と再帰下降構文解析

読了

## 文脈自由文法

生成規則

```
add: num
add: add "+" num
add: add "-" num
num: digit
num: num digit
digit: "0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9"
```

add からはじまって、最後には 数字になる。

[add "+" num]で[add "+" num]を"add"にいれることができる。

(add "+" num) "+" num

((add "+" num) "+" num) "+" num

読了

## 生成規則による演算子の優先順位の表現

>以前はaddが直接numに展開されていたのですが、今回はaddはmulを経由してnumに展開されるルールになりました

これによって、足し算よりも掛け算が優先される。


読了

## 演算子の結合規則

>同じ優先順位の演算子が複数連続して使われているときに、構文木が右に深くなるような生成規則を考えることもできます。

左結合と右結合がある。

読了

## 抽象構文木

木を詳細に書くと冗長になる。  
そのため、必要な部分だけ書いて簡潔に表す。

>このようにコンパクトに表した構文木のことを抽象構文木（abstract syntax tree; AST）といいます。

読了

## 再帰下降構文解析

>パーサを書くときの基本的な戦略は、これらの項一つ一つをそのまま関数一つ一つにマップするというものです。したがってパーサはadd、mul、termという3つの関数を持つことになります。それぞれの関数は、その名前のとおりの記号列をパースします。

読了

## スタックマシン

読了

## スタックマシンへのコンパイル

読了

## x86-64におけるスタックマシンの実現方法

読了
